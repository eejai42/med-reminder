{{#each @root}}
[[FileSetFile/RelativePath[../{{@key}}StateMachine.h]]]
#pragma once
// Adjusted StateMachine.h Template for {{@key}}StateMachine
#include "common.h"

enum class State {
    {{#each MachineStates.MachineState}}
    {{Name}},
    {{/each}}
    // Add additional states here
};

class {{@key}}StateMachine {
private:
    State currentState;

public:
    {{@key}}StateMachine();
    void checkState();

    // State transition utility methods
    void transitionTo(State newState);
    void onExit(State state);
    void onEnter(State state);

    {{#each MachineStates.MachineState}}
    // Enter and Exit methods for {{Name}} state
    void enter{{Name}}();
    void exit{{Name}}();

    // Action handlers for the {{Name}} state
    {{#each FromTransitions.FromTransition}}
    bool has{{../Name}}_{{ActionName}}();
    {{/each}}
    {{/each}}
};

extern {{@key}}StateMachine* stateMachine;

{{!-- StateMachine.cpp Template --}}
[[FileSetFile/RelativePath[../{{@key}}StateMachine.cpp:never]]]
#pragma once
// Adjusted StateMachine.cpp Template for {{@key}}StateMachine
#include "{{@key}}StateMachine.h"

{{@key}}StateMachine::{{@key}}StateMachine() : currentState(State::{{#each FSMs}}{{InitialStateName}}{{/each}}) {
    onEnter(currentState); // Initial state entry actions
}

void {{@key}}StateMachine::checkState() {
    switch (currentState) {
        {{#each MachineStates.MachineState}}
        case State::{{Name}}:
            {{#each FromTransitions.FromTransition}}
            if (has{{../Name}}_{{ActionName}}()) {
                transitionTo(State::{{ToStateName}}); // Transition based on specific action being true
                return;
            }
            {{/each}}
            break;
        {{/each}}
    }
}

void {{@key}}StateMachine::transitionTo(State newState) {
    onExit(currentState);
    currentState = newState;
    onEnter(newState);
}

void {{@key}}StateMachine::onExit(State state) {
    switch (state) {
        {{#each MachineStates.MachineState}}
        case State::{{Name}}:
            exit{{Name}}();
            break;
        {{/each}}
    }
}

void {{@key}}StateMachine::onEnter(State state) {
    switch (state) {
        {{#each MachineStates.MachineState}}
        case State::{{Name}}:
            enter{{Name}}();
            break;
        {{/each}}
    }
}

{{@key}}StateMachine* stateMachine = nullptr;


{{#each MachineStates.MachineState}}
[[FileSetFile/RelativePath[../{{Name}}.cpp:never]]]
#pragma once
#include "MedReminderStateMachine.h"

void {{@../key}}StateMachine::enter{{Name}}() {
    // Actions to perform on entering {{Name}}
}

void {{@../key}}StateMachine::exit{{Name}}() {
    // Actions to perform on exiting {{Name}}
}

{{#each FromTransitions.FromTransition}}
bool {{@../../key}}StateMachine::has{{../Name}}_{{ActionName}}() {
    // Check condition for {{ActionName}} in {{../Name}} state
    return false; // Placeholder implementation
}
{{/each}}
{{/each}}
{{/each}}