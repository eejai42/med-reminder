{{#each @root}}
[[FileSetFile/RelativePath[../{{@key}}StateMachine.h]]]
#pragma once
#include "BaseState.h"
#include "BaseStateMachine.h"
#include <memory>
#include <iostream>

// ***************************************************************
// Declaration for {{@key}}StateMachine and base state classes
// ***************************************************************

class {{@key}}StateMachine : public BaseStateMachine<BaseState<{{@key}}StateMachine>> {
public:
    {{@key}}StateMachine();

    // Other member functions...
};

{{#each MachineStates.MachineState}}

class Base{{Name}} : public BaseState<MedReminderStateMachine> {
public:
    Base{{Name}}(MedReminderStateMachine* machine);

    void onEnter() override;
    void onExit() override;
    void onCheck() override;

    {{#each FromTransitions.FromTransition}}
    virtual bool has{{ActionName}}();
    {{/each}}
};
{{/each}}

[[FileSetFile/RelativePath[../{{@key}}StateMachine.cpp]]]
#include "{{@key}}StateMachine.h"
#include <iostream>
{{#each MachineStates.MachineState}}
#include "{{Name}}.h"
{{/each}}

// ***************************************************************
// Implementation for {{@key}}StateMachine and base state classes
// ***************************************************************

{{@key}}StateMachine::{{@key}}StateMachine() : BaseStateMachine() {
    // Constructor implementation
    // Example: changeState(std::make_unique<{{FSMs.FSM.InitialStateName}}>(this));
}

{{#each MachineStates.MachineState}}
void Base{{Name}}::onCheck() {
    // Handle transitions
    {{#each FromTransitions.FromTransition}}
    if (this->has{{ActionName}}()) {
        machine->changeState(std::make_unique<{{ToStateName}}>(machine));
        return;
    }
    {{/each}}
}
{{/each}}

{{#each MachineStates.MachineState}}
[[FileSetFile/RelativePath[../{{Name}}.h]]]
#pragma once
#include "{{@../key}}StateMachine.h"
// #include "Base{{Name}}.h" // Ensure base class is included if separate

class {{Name}} : public Base{{Name}} {
public:
    using Base{{Name}}::Base{{Name}};
    {{Name}}({{@../key}}StateMachine* machine);

    {{#each FromTransitions.FromTransition}}
    bool has{{ActionName}}() override;
    {{/each}}
};
{{/each}}
{{#each MachineStates.MachineState}}
[[FileSetFile/RelativePath[../{{Name}}.cpp]]]
#pragma once
#include "{{Name}}.h"
#include <iostream> // Include if you use std::cout or similar in implementations

{{Name}}::{{Name}}({{@../key}}StateMachine* machine) : Base{{Name}}(machine) {
    // Constructor implementation, if needed
}
{{/each}}
{{/each}}

[[FileSetFile/RelativePath[../BaseState.h]]]
#pragma once

template<typename MachineType>
class BaseState {
public:
    MachineType* machine;

    BaseState(MachineType* machine) : machine(machine) {}
    virtual ~BaseState() = default;

    virtual void onCheck() = 0; // called in the arduio loop

    virtual void onEnter() = 0; // called when the state is activated
    virtual void onExit() = 0; // called when the state is de-activated
};

[[FileSetFile/RelativePath[../BaseStateMachine.h]]]
#pragma once
#include <memory>
#include "BaseState.h"

template <typename StateType>
class BaseStateMachine
{
protected:
    std::unique_ptr<StateType> currentState;


public:
    BaseStateMachine() = default;
    virtual ~BaseStateMachine() = default;

    void changeState(std::unique_ptr<StateType> newState)
    {
        if (currentState)
        {
            currentState->onExit();
        }
        currentState = std::move(newState);
        if (currentState)
        {
            currentState->onEnter();
        }
    }


    void checkState() {
        if (currentState)
        {
            currentState->onCheck();
        }
    }
};